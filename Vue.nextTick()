在数据改变之后的操作跟改变之后的DOM有关，那么就应该使用Vue.nextTick()

1、Vue声明周期的created() 钩子函数进行的DOM操作一定要放在Vue.nextTick() 的回调函数中，因为created() 执行的时候DOM实际上并未进行任何渲染，
此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。

与之对应的就是mounted 钩子函数，因为该函数执行时所有的DOM挂载和渲染都已完成，此时再钩子函数中进行任何DOM操作都不会有问题。

2、在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放进Vue.nextTick() 的回调函数中

Vue异步执行DOM更新。每当观察到数据更改时，它将打开一个队列并缓冲同一事件循环中发生的所有数据更改。如果同一个监视程序被触发多次，
那么它将只被推入队列一次。这种缓冲的重复数据删除对于避免不必要的计算和DOM操作非常重要。然后，在下一个事件循环“tick”中，
Vue刷新队列并执行实际的(已经被清除的)工作。在内部Vue尝试原生承诺。然后，对异步队列使用MutationObserver和setimmediation，并退回到setTimeout(fn, 0)。

对于一个事件的数据，从“数据更改”->"缓存入数据更新队列"->在某个条件下，将这个缓存数据被更新到DOM（页面出现更新）->这个事件再监听数据更改。
这是一个周期。也就是说，你改了数据，虽然Vue是响应式的更新，有些时候你看起来好像是立刻更新了，但其实不是，Vue把改动的数据先缓存起来了，
要等下一个DOM更新周期到了才会把这些数据更新到DOM里，因此，如果说你只是“看”页面，看不出区别。如果你要在更新完数据后，去操作DOM，
那这个时候就会看到，调试的数据都是对的，但是页面的行为怎么就是错的。
